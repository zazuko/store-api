<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: graphdb.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: graphdb.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { chunkBetween } from './utils.js'
import { Store } from './store.js'
import libGraphDB from 'graphdb'
import isStream from 'is-stream'

const { GraphDBServerClient, ServerClientConfig } = libGraphDB.server
const { RDFMimeType, QueryContentType } = libGraphDB.http
const { RepositoryConfig, RepositoryType, RepositoryClientConfig } = libGraphDB.repository
const { GetQueryPayload, UpdateQueryPayload, QueryType } = libGraphDB.query

/**
 * Class to interact with a GraphDB store
 *
 * @extends Store
 */
export class GraphDB extends Store {
  /**
   * @param {Object} [options={}] Connection params
   * @param {string} [options.user] Username
   * @param {string} [options.password] Password
   * @param {string} [options.endpoint=http://localhost:7200] Endpoint
   */
  constructor (options = {}) {
    super()
    options = Object.assign({ endpoint: 'http://localhost:7200' }, options)

    this.url = options.endpoint
    const serverConfig = new ServerClientConfig(this.url)
      .setTimeout(5000)
      .setHeaders({
        Accept: RDFMimeType.SPARQL_RESULTS_JSON
      })
      .setKeepAlive(true)

    if (options.user &amp;&amp; options.password) {
      serverConfig.useBasicAuthentication(options.user, options.password)
    }

    this._conn = new GraphDBServerClient(serverConfig)
    this._repos = {}
  }

  /**
   * Creates a database
   *
   * @async
   * @param {string} dbname
   */
  async createDb (dbname) {
    const config = new RepositoryConfig(dbname, '', new Map(), '', dbname, RepositoryType.FREE)
    await this.conn.createRepository(config)
    return true
  }

  /**
   * Deletes a database
   *
   * @async
   * @param {string} dbname
   */
  async dropDb (dbname) {
    await this.conn.deleteRepository(dbname)
    return true
  }

  /**
   * Empties a database
   *
   * @async
   * @param {string} dbname
   */
  async clearDb (dbname, options = {}) {
    const repo = await this._getRepo(dbname, options)
    const res = await repo.deleteAllStatements()
    return res || true
  }

  /**
   * Issues an ASK query
   *
   * @async
   * @param {string} dbname
   * @param {string} sparql query
   * @param {Object} [options]
   * @param {string} [options.responseType=application/sparql-results+json]
   */
  async ask (dbname, sparql, options = {}) {
    options = Object.assign({ responseType: RDFMimeType.SPARQL_RESULTS_JSON }, options)
    return this._readQuery(dbname, sparql, QueryType.ASK, options)
  }

  /**
   * Issues a CONSTRUCT query
   *
   * @async
   * @param {string} dbname
   * @param {string} sparql query
   * @param {Object} [options]
   * @param {string} [options.responseType=application/ld+json]
   */
  async construct (dbname, sparql, options = {}) {
    options = Object.assign({ responseType: RDFMimeType.JSON_LD }, options)
    return this._readQuery(dbname, sparql, QueryType.CONSTRUCT, options)
  }

  /**
   * Issues a DESCRIBE query
   *
   * @async
   * @param {string} dbname
   * @param {string} sparql query
   * @param {Object} [options]
   * @param {string} [options.responseType=application/ld+json]
   */
  async describe (dbname, sparql, options = {}) {
    options = Object.assign({ responseType: RDFMimeType.JSON_LD }, options)
    return this._readQuery(dbname, sparql, QueryType.DESCRIBE, options)
  }

  /**
   * Issues a SELECT query
   *
   * @async
   * @param {string} dbname
   * @param {string} sparql query
   * @param {Object} [options]
   * @param {string} [options.responseType=application/sparql-results+json]
   */
  async select (dbname, sparql, options = {}) {
    options = Object.assign({ responseType: RDFMimeType.SPARQL_RESULTS_JSON }, options)
    return this._readQuery(dbname, sparql, QueryType.SELECT, options)
  }

  /**
   * Issues a SPARQL UPDATE query
   *
   * @async
   * @param {string} dbname
   * @param {string} sparql query
   * @param {Object} [options]
   * @param {Object} [options.inference=false]
   * @param {string} [options.timeout=30_000]
   * @param {string} [options.responseType=application/sparql-results+json]
   */
  async update (dbname, sparql, options = {}) {
    options = Object.assign({ responseType: RDFMimeType.SPARQL_RESULTS_JSON }, options)
    const repo = await this._getRepo(dbname, options)

    const payload = new UpdateQueryPayload()
      .setQuery(sparql)
      .setContentType(QueryContentType.X_WWW_FORM_URLENCODED)
      .setInference(Boolean(options.inference))
      .setTimeout(options.timeout || 30_000)

    return repo.update(payload).then((res) => res || true)
  }

  /**
   * Loads triples or quads into a database
   *
   * @async
   * @param {string} dbname
   * @param {string|Buffer} ntriples triples or quads
   * @param {string=} graph named graph to insert to, defaults to default graph
   */
  async import (dbname, ntriples, graph) {
    const mapper = graph
      ? (chunk) => `INSERT DATA { GRAPH &lt;${graph}> { ${chunk} } }`
      : (chunk) => `INSERT DATA { ${chunk} }`

    const queries = chunkBetween(ntriples, mapper, 1_000)
    const results = await Promise.all(
      queries.map((query) => this.update(dbname, query))
    )
    return results.every(Boolean)
  }

  async _readQuery (dbname, sparql, type, options = {}) {
    const repo = await this._getRepo(dbname, options)
    const payload = new GetQueryPayload()
      .setQuery(sparql)
      .setQueryType(type)
      .setResponseType(options.responseType)

    return this._handleResults(await repo.query(payload))
  }

  async _getRepo (dbname, options) {
    options = Object.assign({ readTimeout: 30_000, writeTimeout: 30_000 }, options)

    const repositoryClientConfig = new RepositoryClientConfig(this.url)
      .setEndpoints([`${this.url}/repositories/${dbname}`])
      .setReadTimeout(options.readTimeout)
      .setWriteTimeout(options.writeTimeout)

    const repo = await this.conn.getRepository(dbname, repositoryClientConfig)

    ;['N3Parser', 'NQuadsParser', 'NTriplesParser', 'TriGParser', 'TurtleParser', 'JsonLDParser', 'RDFXmlParser', 'SparqlJsonResultParser', 'SparqlXmlResultParser'].forEach((parser) => {
      repo.registerParser(new libGraphDB.parser[parser]())
    })

    return repo
  }

  async _handleResults (result) {
    if (!isStream(result)) {
      return result
    }

    const results = []

    result.on('data', (bindings) => {
      results.push(bindings)
    })

    return new Promise((resolve) => {
      result.on('end', () => {
        resolve(results)
      })
    })
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Fuseki.html">Fuseki</a></li><li><a href="GraphDB.html">GraphDB</a></li><li><a href="Stardog.html">Stardog</a></li></ul><h3>Global</h3><ul><li><a href="global.html#chunkBetween">chunkBetween</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Apr 21 2021 16:42:49 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
